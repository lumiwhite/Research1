from common import *

def make_h_x_functions(f_list, g_list):
    result = []
    for j in range(J):
        row = []
        for l in range(l_h):
            row.append(f_list[(l-j)%l_h])
        for l in range(l_h):
            row.append(g_list[(l-j)%l_h])
        result.append(row)
    return result

def make_h_z_functions(f_list, g_list):
    result = []
    for j in range(J):
        row = []
        for l in range(l_h):
            row.append(g_list[(j-l)%l_h].inv())
        for l in range(l_h):
            row.append(f_list[(j-l)%l_h].inv())
        result.append(row)
    return result

def get_canonical_cycle(seq):
    seq_arr = np.array(seq)
    min_seq = seq_arr.copy()
    for i in range(1, len(seq_arr)):
        shifted = np.roll(seq_arr, i)
        if shifted.tolist() < min_seq.tolist():
            min_seq = shifted.copy()
    return tuple(min_seq.tolist())

def is_valid_cycle(seq):
    for i in range(len(seq) - 1):
        if seq[i] == seq[i+1]:
            return False
    if seq[0] == seq[-1]:
        return False 
    return True

def generate_sequences(target_length, num_values):
    valid_cycles = set()
    for p in itertools.product(range(num_values), repeat=target_length):
        if is_valid_cycle(p):
            canonical = get_canonical_cycle(p)
            valid_cycles.add(canonical)
    return valid_cycles

def make_cols_list():
    result_list = []
    for i in range(1, l_h+1):
        result_list.extend(generate_sequences(2*i, L))
    return result_list

def make_cycle(cols, j):
    cycle = []
    print
    for j in range(int(len(cols)/2)):
        cycle.append([j%2, cols[2*j]])
        cycle.append([j%2, cols[2*j+1]])
        cycle.append([(1-j)%2, cols[2*j+1]])
        cycle.append([(1-j)%2, cols[(2*j+2)%len(cols)]])
    return cycle

def make_utcbc_list():
    utcbc_list = []
    for k in range(3):
        utcbc_cols = []
        for i in range(l_h):
            utcbc_cols.append(i)
            utcbc_cols.append(l_h + (-i + k)%l_h)
        utcbc_list.append(tuple(get_canonical_cycle(utcbc_cols)))
    return utcbc_list

def is_utcbc(cols):    
    utcbc_list = make_utcbc_list()
    return cols in utcbc_list